<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>(* ============================================================================&#xD;
   FESTO AG &amp; Co. KG, Esslingen - Copyright 2015. All rights reserved.                       &#xD;
 -----------------------------------------------------&#xD;
 function block:	FHPP_CTRL&#xD;
 description:    		function block to control the motorcontroller&#xD;
 version:        		V 1.0        &#xD;
 composer:       	chmm &#xD;
 last update:    		June 2015                                                                           &#xD;
 -----------------------------------------------------&#xD;
Date        			Name              				Activity                                                                              &#xD;
June 2015  		Christian Hammer		created&#xD;
============================================================================ *)&#xD;
&#xD;
// ENO BIT for using this FB in ladder is always true&#xD;
FB_ENO := TRUE;&#xD;
&#xD;
// EN BIT for using this FB in ladder - if false skip the routine&#xD;
IF NOT FB_EN THEN&#xD;
	RETURN;&#xD;
END_IF;&#xD;
&#xD;
&#xD;
(***************************************************************************************************************************************************&#xD;
*********** CONTROL FUNCTION BLOCK *********************************************************************************************************&#xD;
***************************************************************************************************************************************************)&#xD;
&#xD;
(*-------------------------------------------------------	*)&#xD;
(* assignment of input data							  				*)&#xD;
(*-------------------------------------------------------	*)&#xD;
&#xD;
//assign SCON data&#xD;
DriveEnabled					:= FML_REF.FHPP.IN.SCON.ENABLED;&#xD;
Ready								:= FML_REF.FHPP.IN.SCON.OPEN;&#xD;
Warning							:= FML_REF.FHPP.IN.SCON.WARN;&#xD;
Fault									:= FML_REF.FHPP.IN.SCON.FAULT;&#xD;
SupplyVoltagePresent		:= FML_REF.FHPP.IN.SCON.VLOAD;&#xD;
ControlFCT_HMI				:= FML_REF.FHPP.IN.SCON.FCT;&#xD;
&#xD;
//assign SPOS data&#xD;
HaltActive						:= FML_REF.FHPP.IN.SPOS.HALT;&#xD;
AckStart							:= FML_REF.FHPP.IN.SPOS.ACK;&#xD;
MotionComplete				:= FML_REF.FHPP.IN.SPOS.MC;&#xD;
AckTeach							:= FML_REF.FHPP.IN.SPOS.TEACH;&#xD;
DriveIsMoving					:= FML_REF.FHPP.IN.SPOS.MOV;&#xD;
FollowingError					:= FML_REF.FHPP.IN.SPOS.DEV;&#xD;
StandstillControl				:= FML_REF.FHPP.IN.SPOS.STILL;&#xD;
HomingValid					:= FML_REF.FHPP.IN.SPOS.REF;&#xD;
&#xD;
//assign byte3 data&#xD;
IF FML_REF.FHPP.IN.SCON.OPM1 THEN																// ===== directmode active =====&#xD;
	ActualRecordNo			:= 0;&#xD;
	RC1								:= FALSE;&#xD;
	RCC								:= FALSE;	&#xD;
	&#xD;
	(* coding of operation mode state *)&#xD;
	IF TestABit(FML_REF.FHPP.IN.Byte3, 7) 															// function bit is activ (Bit 7)&#xD;
	 AND (FML_REF.DeviceType = CMMP_AS) THEN											(* CMMP-AS *)	&#xD;
		&#xD;
		IF FML_REF.FHPP.IN.SCON.OPM1 THEN&#xD;
			StateOPM				:= 1;&#xD;
		ELSE&#xD;
			StateOPM				:= 0;&#xD;
		END_IF;&#xD;
		&#xD;
		IF FML_REF.FHPP.IN.SCON.OPM2 THEN&#xD;
			StateOPM				:= StateOPM + 2;&#xD;
		END_IF;&#xD;
		&#xD;
		IF TestABit(FML_REF.FHPP.IN.Byte3, 1) THEN&#xD;
			StateOPM				:= StateOPM + 4;														// SDIR_B1: COM1&#xD;
		END_IF;&#xD;
		&#xD;
		IF TestABit(FML_REF.FHPP.IN.Byte3, 2) THEN&#xD;
			StateOPM				:= StateOPM + 8;														// SDIR_B2: COM2&#xD;
		END_IF;&#xD;
		&#xD;
		IF TestABit(FML_REF.FHPP.IN.Byte3, 3) THEN												// SDIR_B3: FNUM1&#xD;
			ActualFunctionNo	:= 1;&#xD;
		ELSE&#xD;
			ActualFunctionNo	:= 0;&#xD;
		END_IF;&#xD;
		&#xD;
		IF TestABit(FML_REF.FHPP.IN.Byte3, 4) THEN												// SDIR_B4: FNUM2&#xD;
			ActualFunctionNo	:= ActualFunctionNo + 2;&#xD;
		END_IF;&#xD;
		&#xD;
		IF TestABit(FML_REF.FHPP.IN.Byte3, 5) THEN												// SDIR_B5: FGRP1&#xD;
			ActualFunctionGroup	:= 1;&#xD;
		ELSE&#xD;
			ActualFunctionGroup	:= 0;&#xD;
		END_IF;&#xD;
		&#xD;
		IF TestABit(FML_REF.FHPP.IN.Byte3, 6) THEN												// SDIR_B6: FGRP2&#xD;
			ActualFunctionGroup	:= ActualFunctionGroup + 2;&#xD;
		END_IF;&#xD;
		&#xD;
		FunctionIsActive			:= TRUE;																	// SDIR_B7:FUNC&#xD;
		&#xD;
		VelocityLimitReached	:= FALSE;																	&#xD;
		StrokeLimitReached		:= FALSE;							&#xD;
&#xD;
	ELSE																													// function bit is not activ (Bit 7)&#xD;
		IF FML_REF.FHPP.IN.SCON.OPM1 THEN&#xD;
			StateOPM				:= 1;&#xD;
		ELSE&#xD;
			StateOPM				:= 0;&#xD;
		END_IF;&#xD;
		&#xD;
		IF FML_REF.FHPP.IN.SCON.OPM2 THEN&#xD;
			StateOPM				:= StateOPM + 2;&#xD;
		END_IF;&#xD;
		&#xD;
		IF TestABit(FML_REF.FHPP.IN.Byte3, 1) THEN&#xD;
			StateOPM				:= StateOPM + 4;														// SDIR_B1: COM1&#xD;
		END_IF;&#xD;
		&#xD;
		IF TestABit(FML_REF.FHPP.IN.Byte3, 2) THEN&#xD;
			StateOPM				:= StateOPM + 8;														// SDIR_B2: COM2&#xD;
		END_IF;&#xD;
		&#xD;
		IF TestABit(FML_REF.FHPP.IN.Byte3, 3) THEN&#xD;
			StateOPM				:= StateOPM + 16;													// SDIR_B3: CONT&#xD;
		END_IF;&#xD;
		&#xD;
		VelocityLimitReached	:= TestABit(FML_REF.FHPP.IN.Byte3, 4);					// SDIR_B4: VLIM_REL&#xD;
		StrokeLimitReached		:= TestABit(FML_REF.FHPP.IN.Byte3, 5);					// SDIR_B5: XLIM&#xD;
			&#xD;
		FunctionIsActive			:= FALSE;																	// SDIR_B7: FUNC&#xD;
		ActualFunctionNo		:= 0; &#xD;
		ActualFunctionGroup	:= 0;&#xD;
	END_IF;&#xD;
	&#xD;
ELSE																													// ===== recordmode active =====              &#xD;
	ActualRecordNo			:= BYTE_TO_INT (FML_REF.FHPP.IN.Byte3);				// byte_3 = record number&#xD;
	RC1								:= TestABit(FML_REF.FHPP.IN.ActValue1, 0);&#xD;
	RCC								:= TestABit(FML_REF.FHPP.IN.ActValue1, 1);	&#xD;
	(* coding of operation mode state *)&#xD;
	IF FML_REF.FHPP.IN.SCON.OPM1 THEN&#xD;
		StateOPM				:= 1;&#xD;
	ELSE&#xD;
		StateOPM				:= 0;&#xD;
	END_IF;&#xD;
	&#xD;
	IF FML_REF.FHPP.IN.SCON.OPM2 THEN&#xD;
		StateOPM				:= StateOPM + 2;&#xD;
	END_IF;&#xD;
&#xD;
	VelocityLimitReached	:= FALSE;&#xD;
	StrokeLimitReached		:= FALSE;&#xD;
	&#xD;
	ActualFunctionNo		:= 0; &#xD;
	ActualFunctionGroup	:= 0;&#xD;
END_IF;&#xD;
&#xD;
&#xD;
CASE StateOPM OF&#xD;
	0: (* recordmode *)&#xD;
		ActualVelocity			:= 0;&#xD;
		ActualForce				:= 0;&#xD;
		ActualRotRamp		:= 0;&#xD;
		ActualRotSpeed		:= 0;&#xD;
		ActualPosition			:= DWORD_TO_DINT(FML_REF.FHPP.IN.ActValue2);&#xD;
		&#xD;
	1: (* directmode position control *)&#xD;
	 	ActualVelocity 			:= BYTE_TO_SINT(FML_REF.FHPP.IN.ActValue1);&#xD;
		ActualForce				:= 0;&#xD;
		ActualRotRamp		:= 0;&#xD;
		ActualRotSpeed		:= 0;&#xD;
		ActualPosition			:= DWORD_TO_DINT(FML_REF.FHPP.IN.ActValue2);&#xD;
&#xD;
	5:  (* directmode force control *)&#xD;
		IF (FML_REF.DeviceType = EMCA_EC) THEN		(*******EMCA-EC*******)	&#xD;
			ActualVelocity		:= BYTE_TO_SINT(FML_REF.FHPP.IN.ActValue1);&#xD;
			ActualForce			:= DWORD_TO_DINT(FML_REF.FHPP.IN.ActValue2);&#xD;
			ActualPosition		:= 0;&#xD;
		ELSE 																	(*******CMMP-AS, CMMS_AS, CMMS_ST, CMMD_AS or CMMO-ST*******)	&#xD;
			ActualVelocity		:= 0;&#xD;
			ActualForce			:= BYTE_TO_SINT(FML_REF.FHPP.IN.ActValue1);&#xD;
			ActualPosition		:= DWORD_TO_DINT(FML_REF.FHPP.IN.ActValue2);&#xD;
		END_IF;&#xD;
		ActualRotRamp		:= 0;&#xD;
		ActualRotSpeed		:= 0;	&#xD;
	&#xD;
&#xD;
	9:  (* directmode rotation-speed-control *)&#xD;
		ActualVelocity			:= 0;&#xD;
		ActualForce				:= 0;&#xD;
		ActualRotRamp		:= BYTE_TO_SINT(FML_REF.FHPP.IN.ActValue1);&#xD;
 		ActualRotSpeed		:= DWORD_TO_DINT(FML_REF.FHPP.IN.ActValue2);&#xD;
		ActualPosition			:= 0;&#xD;
	&#xD;
	ELSE&#xD;
		ActualVelocity			:= 0;&#xD;
		ActualForce				:= 0;&#xD;
		ActualRotRamp		:= 0;&#xD;
		ActualRotSpeed		:= 0;&#xD;
		ActualPosition			:= 0;&#xD;
END_CASE;&#xD;
&#xD;
StateOPMString 				:= GetStateOPMString(StateOPM);									// specify state OPM string&#xD;
&#xD;
(*------------------------------------------------------*)&#xD;
(* assignment of output data						  			 *)&#xD;
(*------------------------------------------------------*)&#xD;
&#xD;
OPMString						:= GetOPMString(OPM);   												// set the OPM string&#xD;
&#xD;
//assign CCON data&#xD;
FML_REF.FHPP.OUT.CCON.ENABLE		:= EnableDrive;&#xD;
FML_REF.FHPP.OUT.CCON.STOP			:= Stop;&#xD;
FML_REF.FHPP.OUT.CCON.BRAKE		:= Brake;&#xD;
FML_REF.FHPP.OUT.CCON.RESET		:= ResetFault;&#xD;
FML_REF.FHPP.OUT.CCON.res				:= FALSE;&#xD;
FML_REF.FHPP.OUT.CCON.LOCK			:= HMIAccessLocked;&#xD;
FML_REF.FHPP.OUT.CCON.OPM1		:= TestABit(INT_TO_WORD(OPM), 0); 			&#xD;
FML_REF.FHPP.OUT.CCON.OPM2		:= TestABit(INT_TO_WORD(OPM), 1); 	&#xD;
&#xD;
//assign CPOS data&#xD;
FML_REF.FHPP.OUT.CPOS.HALT			:= Halt;&#xD;
FML_REF.FHPP.OUT.CPOS.START		:= StartTask;&#xD;
FML_REF.FHPP.OUT.CPOS.HOM			:= StartHoming;&#xD;
FML_REF.FHPP.OUT.CPOS.JOGP			:= JoggingPos;&#xD;
FML_REF.FHPP.OUT.CPOS.JOGN			:= JoggingNeg;&#xD;
FML_REF.FHPP.OUT.CPOS.TEACH		:= TeachActualValue;&#xD;
FML_REF.FHPP.OUT.CPOS.CLEAR		:= ClearRemainingPosition;&#xD;
FML_REF.FHPP.OUT.CPOS.res				:= FALSE;&#xD;
&#xD;
//assign byte3 data&#xD;
IF (TestABit(INT_TO_WORD(OPM), 0))  THEN  						// ===== 	directmode  ===== &#xD;
	IF Relative THEN&#xD;
		SetABit(FML_REF.FHPP.OUT.Byte3, 0);								// CDIR_B0: ABS == TRUE&#xD;
	ELSE	&#xD;
		ResetABit(FML_REF.FHPP.OUT.Byte3, 0);							// CDIR_B0: ABS == FALSE&#xD;
	END_IF;	&#xD;
	&#xD;
	IF (TestABit(INT_TO_WORD(OPM), 2)) THEN&#xD;
		SetABit(FML_REF.FHPP.OUT.Byte3, 1);								// CDIR_B1: former ControlModeB1 == TRUE&#xD;
	ELSE	&#xD;
		ResetABit(FML_REF.FHPP.OUT.Byte3, 1);							// CDIR_B1: former ControlModeB1 == FALSE&#xD;
	END_IF;	&#xD;
	&#xD;
	IF (TestABit(INT_TO_WORD(OPM), 3)) THEN&#xD;
		SetABit(FML_REF.FHPP.OUT.Byte3, 2);								// CDIR_B2: former ControlModeB2 == TRUE&#xD;
	ELSE	&#xD;
		ResetABit(FML_REF.FHPP.OUT.Byte3, 2);							// CDIR_B2: former ControlModeB2 == FALSE&#xD;
	END_IF;&#xD;
	&#xD;
	IF ExecuteFunction 																// function bit is selected&#xD;
	 AND (FML_REF.DeviceType = CMMP_AS) THEN				(* CMMP-AS *)								&#xD;
		IF SetFunctionNo=1 THEN&#xD;
			SetABit(FML_REF.FHPP.OUT.Byte3, 3);&#xD;
			ResetABit(FML_REF.FHPP.OUT.Byte3, 4);	&#xD;
		ElSIF SetFunctionNo=2 THEN&#xD;
			ResetABit(FML_REF.FHPP.OUT.Byte3, 3);	&#xD;
			SetABit(FML_REF.FHPP.OUT.Byte3, 4);&#xD;
		ELSIF SetFunctionNo=3 THEN&#xD;
			SetABit(FML_REF.FHPP.OUT.Byte3, 3);&#xD;
			SetABit(FML_REF.FHPP.OUT.Byte3, 4);&#xD;
		ELSE&#xD;
			ResetABit(FML_REF.FHPP.OUT.Byte3, 3);	&#xD;
			ResetABit(FML_REF.FHPP.OUT.Byte3, 4);	&#xD;
		END_IF;&#xD;
		&#xD;
		IF SetFunctionGroup=1 THEN&#xD;
			SetABit(FML_REF.FHPP.OUT.Byte3, 5);&#xD;
			ResetABit(FML_REF.FHPP.OUT.Byte3, 6);	&#xD;
		ElSIF SetFunctionGroup=2 THEN&#xD;
			ResetABit(FML_REF.FHPP.OUT.Byte3, 5);	&#xD;
			SetABit(FML_REF.FHPP.OUT.Byte3, 6);&#xD;
		ELSIF SetFunctionGroup=3 THEN&#xD;
			SetABit(FML_REF.FHPP.OUT.Byte3, 5);&#xD;
			SetABit(FML_REF.FHPP.OUT.Byte3, 6);&#xD;
		ELSE&#xD;
			ResetABit(FML_REF.FHPP.OUT.Byte3, 5);	&#xD;
			ResetABit(FML_REF.FHPP.OUT.Byte3, 6);	&#xD;
		END_IF;	&#xD;
	&#xD;
		SetABit(FML_REF.FHPP.OUT.Byte3, 7);								// CDIR_B7: FUNC == TRUE&#xD;
	&#xD;
	&#xD;
	ELSE																						// function bit is not activ (Bit 7)&#xD;
	&#xD;
		ResetABit(FML_REF.FHPP.OUT.Byte3, 3);							// CDIR_B3: CONT&#xD;
		ResetABit(FML_REF.FHPP.OUT.Byte3, 4);							// CDIR_B4: CTOG_REL&#xD;
	&#xD;
		IF DeactivateStrokeLimit THEN&#xD;
			SetABit(FML_REF.FHPP.OUT.Byte3, 5);							// CDIR_B5: XLIM	== TRUE&#xD;
		ELSE&#xD;
			ResetABit(FML_REF.FHPP.OUT.Byte3, 5);						// CDIR_B5: XLIM	== FALSE&#xD;
		END_IF;&#xD;
		&#xD;
		ResetABit(FML_REF.FHPP.OUT.Byte3, 7);							// CDIR_B7: FUNC == FALSE&#xD;
		&#xD;
	END_IF;&#xD;
	&#xD;
&#xD;
ELSE            // &gt;&gt;&gt; recordmode &lt;&lt;&lt; &#xD;
	FML_REF.FHPP.OUT.Byte3	:= INT_TO_BYTE(RecordNo);	// byte 3 = record no.&#xD;
END_IF;&#xD;
&#xD;
CASE OPM OF&#xD;
	0:	(* recordmode *)&#xD;
		FML_REF.FHPP.OUT.SetValue1	:= 0;    							// byte 4 &#xD;
		FML_REF.FHPP.OUT.SetValue2	:= 0;    							// byte 5...8&#xD;
  	&#xD;
	1: (* directmode position control *)&#xD;
		FML_REF.FHPP.OUT.SetValue1	:= USINT_TO_BYTE(MIN(SetValueVelocity, USINT#100));			// byte 4 (Range 0..100)&#xD;
  		FML_REF.FHPP.OUT.SetValue2	:= DINT_TO_DWORD(SetValuePosition);										// byte 5...8&#xD;
  &#xD;
	5:	(* directmode force control *)&#xD;
		IF (FML_REF.DeviceType = CMMP_AS) THEN																					(* CMMP-AS *)&#xD;
			FML_REF.FHPP.OUT.SetValue1	:= USINT_TO_BYTE(MIN(SetValueForceRamp, USINT#100));	// byte 4 (permissible range of value is 0 to 100)&#xD;
			&#xD;
		ELSIF (FML_REF.DeviceType = CMMO_ST) &#xD;
		   OR (FML_REF.DeviceType = EMCA_EC) THEN 																				(* CMMO-ST and EMCA-EC *)&#xD;
			FML_REF.FHPP.OUT.SetValue1	:= USINT_TO_BYTE(MIN(SetValueVelocity, USINT#100));		// byte 4 (permissible range of value is 0 to 100)&#xD;
			&#xD;
		ELSE																																					(* CMMS_AS and CMMS_ST and CMMD_AS *)&#xD;
			FML_REF.FHPP.OUT.SetValue1	:= 0;																							// byte 4 not used in controller&#xD;
		END_IF;&#xD;
				&#xD;
		FML_REF.FHPP.OUT.SetValue2		:= DINT_TO_DWORD(SetValueForce);										// force w/o limitation&#xD;
  &#xD;
	9:	(* directmode rotation-speed-control *)&#xD;
		FML_REF.FHPP.OUT.SetValue1	:= USINT_TO_BYTE(MIN(SetValueRotRamp, USINT#100));			// byte 4 (permissible range of value is 0 to 100&#xD;
		FML_REF.FHPP.OUT.SetValue2	:= DINT_TO_DWORD(SetValueRotSpeed);									// byte 5...8&#xD;
END_CASE;&#xD;
&#xD;
&#xD;
(* ===== end of function block ====================================================== *)</Text></StructuredTextModel>