<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>(* ============================================================================&#xD;
   FESTO AG &amp; Co. KG, Esslingen - Copyright 2015. All rights reserved.                       &#xD;
 -----------------------------------------------------&#xD;
 function block:	FPC_DIAG_BUFFER  &#xD;
 description:    		function block to read diagnostic buffer of the motorcontroller&#xD;
 version:        		V 1.0        &#xD;
 composer:       	chmm &#xD;
 last update:    		June 2015                                                                           &#xD;
 -----------------------------------------------------&#xD;
Date        			Name              				Activity                                                                              &#xD;
June 2015  		Christian Hammer		created&#xD;
============================================================================ *)&#xD;
&#xD;
// ENO BIT for using this FB in ladder is always true&#xD;
FB_ENO := TRUE;&#xD;
&#xD;
// EN BIT for using this FB in ladder - if false skip the routine&#xD;
IF NOT FB_EN THEN&#xD;
	RETURN;&#xD;
END_IF;&#xD;
&#xD;
(* ====== initial block routine ======================================================= *)&#xD;
(* ----- get MemberID for this function block -------------------------------------------------------------------------------- *)&#xD;
IF NOT bInit THEN &#xD;
 	FML_REF.MemberIDmax		:= FML_REF.MemberIDmax +1;&#xD;
	lMemberID							:= FML_REF.MemberIDmax;&#xD;
	bInit										:= TRUE;&#xD;
	Status.Err:=FALSE; Status.Cat:=FML_STATUS_CATEGORY_function_block; Status.ID:=FML_STATUS_ID_FB_init_active; &#xD;
END_IF;&#xD;
&#xD;
	&#xD;
(* ====== supervision of timeout ==================================== *)&#xD;
(* ----- timer to monitor a timeout of the function block ------------*)&#xD;
TONInst(IN := TimeStart, PT := TimeoutTime);&#xD;
IF TONInst.Q THEN&#xD;
	Status.Err:=TRUE; Status.Cat:=FML_STATUS_CATEGORY_function_block; Status.ID:=FML_STATUS_ID_FB_timeout;&#xD;
	Done								:= TRUE;&#xD;
	StepNo							:= 100;&#xD;
END_IF	;	&#xD;
&#xD;
&#xD;
(* ===== logic part ============================================================= *)&#xD;
(* ----- ASSIGNMENT OF STATUS ------------------------------------------------------------------------------------------ *)&#xD;
IF NOT Execute AND(StepNo &lt;&gt; 0) THEN&#xD;
	StepNo							:= 0;&#xD;
	FML_REF.MemberID		:= 0;&#xD;
	FML_REF.ReqID				:= FML_FPC_REQ_none;&#xD;
	FML_REF.PNU					:= 0;&#xD;
	FML_REF.Subindex			:= 0;&#xD;
	FML_REF.Value					:= 0;&#xD;
END_IF;&#xD;
&#xD;
CASE StepNo OF&#xD;
	0:(* init some variables *)&#xD;
		Done							:= FALSE;&#xD;
		TimeStart						:= FALSE;&#xD;
		ValidEntries					:= 0;&#xD;
		ParamNo						:= 0;&#xD;
		ixPNU							:= 0;&#xD;
		Status.Err:=FALSE; Status.Cat:=FML_STATUS_CATEGORY_no_category; Status.ID:=FML_STATUS_ID_FB_no_error; &#xD;
	&#xD;
		IF (FML_REF.MemberID = 0) AND Execute THEN&#xD;
			FML_REF.MemberID		:= lMemberID;&#xD;
			iSI										:= 1;    					// Subindex (counter)&#xD;
			StepNo   							:= 10;					// read message&#xD;
			Status.Err:=FALSE; Status.Cat:=FML_STATUS_CATEGORY_function_block; Status.ID:=FML_STATUS_ID_FB_busy; &#xD;
&#xD;
			&#xD;
		ELSIF (FML_REF.MemberID &lt;&gt; lMemberId) AND Execute THEN&#xD;
			Status.Err:=FALSE; Status.Cat:=FML_STATUS_CATEGORY_function_block; Status.ID:=FML_STATUS_ID_FB_other_fb_active; 					// device is locked by another FB - wait&#xD;
		END_IF;&#xD;
&#xD;
	10:(* read valid entries *)&#xD;
		TimeStart									:= TRUE;&#xD;
		IF NOT FML_REF.Done THEN&#xD;
			TimeStart								:= FALSE;&#xD;
			IF (FML_REF.DeviceType = CMMP_AS) THEN						(*******CMMP-AS*******)	&#xD;
				FML_REF.FPCC_Modus		:= FML_FPC_MODUS_PNU_11BIT;&#xD;
				max_iSI								:= 32;&#xD;
				StepNo							:= 20;&#xD;
			ELSIF (FML_REF.DeviceType = CMMS_AS) OR (FML_REF.DeviceType = CMMS_ST) OR (FML_REF.DeviceType = CMMD_AS) THEN	(* CMMP-AS or CMMS_AS or CMMS_ST or CMMD_AS *)&#xD;
				FML_REF.FPCC_Modus 	:= FML_FPC_MODUS_PNU_11BIT;&#xD;
				max_iSI								:= 4;&#xD;
				StepNo							:= 20;		&#xD;
			ELSE 																					(*******EMCA-EC or CMMO-ST*******)	&#xD;
				FML_REF.FPCC_Modus 	:= FML_FPC_MODUS_PNU_16BIT;&#xD;
				FML_REF.PNU					:= 204; 					// PNU from array;&#xD;
				FML_REF.Subindex			:= 4;   					// actual Subindex&#xD;
				StepNo							:= 12;&#xD;
				FML_REF.ReqID				:= FML_FPC_REQ_read_array;&#xD;
			END_IF	;&#xD;
		END_IF;&#xD;
  &#xD;
	12:(* done read valid entries *)&#xD;
		TimeStart									:= TRUE;&#xD;
		&#xD;
		IF FML_REF.Done AND NOT FML_REF.Err THEN&#xD;
			TimeStart								:= FALSE;&#xD;
			FML_REF.ReqID					:= FML_FPC_REQ_none;&#xD;
			ValidEntries							:= DINT_TO_INT(FML_REF.ActValue);&#xD;
			max_iSI									:= ValidEntries;&#xD;
			StepNo								:= 20;&#xD;
			&#xD;
		ELSIF FML_REF.Done AND FML_REF.Err THEN&#xD;
			Status.Err:=TRUE; Status.Cat:=FML_STATUS_CATEGORY_parameter_transfer; Status.ID:=FML_REF.ActValue; &#xD;
			StepNo								:= 30;&#xD;
		END_IF;  &#xD;
  &#xD;
	20: (* read parameter axPNU[ixPNU].iSI *)&#xD;
		TimeStart									:= TRUE;&#xD;
		&#xD;
		IF NOT FML_REF.Done THEN&#xD;
			TimeStart								:= FALSE;&#xD;
			FML_REF.PNU						:= awPNU[ixPNU]; 					// PNU from array;&#xD;
			FML_REF.Subindex				:= iSI;         								// actual subindex&#xD;
			FML_REF.ReqID					:= FML_FPC_REQ_read_array;&#xD;
			StepNo								:= 21;&#xD;
		END_IF;&#xD;
&#xD;
	21:(* done parameter*)&#xD;
		TimeStart									:= TRUE;&#xD;
	&#xD;
		IF FML_REF.Done AND NOT FML_REF.Err THEN&#xD;
			TimeStart								:= FALSE;&#xD;
			FML_REF.ReqID					:= FML_FPC_REQ_none;&#xD;
			diValue								:= FML_REF.ActValue;&#xD;
			&#xD;
			CASE ixPNU OF&#xD;
				0:&#xD;
				BufferForDiagEvent[0]		:=DINT_TO_BYTE(diValue);&#xD;
				AryByteTo(BufferForDiagEvent[0], 1, _LOW_HIGH, DiagBuff[iSI].DiagEvent);&#xD;
				sEventBuffer						:= FML_DiagEventString(diValue);&#xD;
	&#xD;
				1:&#xD;
				DiagBuff[iSI].DiagMsgNumber			:= diValue;&#xD;
				DiagBuff[iSI].DiagMsgDescription		:= FaultString(diValue, FML_REF.DeviceType);&#xD;
				&#xD;
				IF diValue &lt;&gt; 0 THEN&#xD;
					ParamNo											:= iSI;&#xD;
				END_IF;					&#xD;
&#xD;
				2:&#xD;
				DiagBuff[iSI].DiagTimeStamp 				:= DINT_TO_DWORD(diValue);&#xD;
 &#xD;
			END_CASE;&#xD;
    &#xD;
			ixPNU 				:= ixPNU + 1;   		// adress next PNU&#xD;
			IF ixPNU &lt; 3 THEN     						// excecute this PNU&#xD;
				StepNo		:= 20;&#xD;
			ELSE                  								// goto next subindex&#xD;
				StepNo		:= 22;&#xD;
			END_IF;&#xD;
&#xD;
		ELSIF FML_REF.Done AND FML_REF.Err THEN&#xD;
			Status.Err:=TRUE; Status.Cat:=FML_STATUS_CATEGORY_parameter_transfer; Status.ID:=FML_REF.ActValue; &#xD;
			StepNo			:= 30;&#xD;
		END_IF;&#xD;
&#xD;
	22: // prepare next subindex 		&#xD;
		IF (FML_REF.DeviceType = CMMP_AS) &#xD;
		OR (FML_REF.DeviceType = CMMS_AS) &#xD;
		OR (FML_REF.DeviceType = CMMS_ST) &#xD;
		OR (FML_REF.DeviceType = CMMD_AS) THEN				(* CMMP-AS or CMMS_AS or CMMS_ST or CMMD_AS *)	&#xD;
			IF (DiagBuff[iSI].DiagMsgNumber =  0) THEN&#xD;
				iSI					:= iSI - 1;&#xD;
				ValidEntries	:= ParamNo;&#xD;
				Status.Err:=FALSE; Status.Cat:=FML_STATUS_CATEGORY_no_category; Status.ID:=FML_STATUS_ID_FB_no_error; &#xD;
				StepNo		:= 30;&#xD;
			ELSIF (ParamNo	= max_iSI)	THEN&#xD;
				ValidEntries	:= ParamNo;&#xD;
				Status.Err:=FALSE; Status.Cat:=FML_STATUS_CATEGORY_no_category; Status.ID:=FML_STATUS_ID_FB_no_error; &#xD;
				StepNo		:= 30;&#xD;
			ELSE										//  read the next PNU set&#xD;
				ixPNU			:= 0;&#xD;
				StepNo		:= 20;&#xD;
			END_IF;&#xD;
		ELSE																					(*******EMCA-EC or CMMO-ST*******)&#xD;
			IF iSI &gt;= max_iSI THEN		//   finish at 16&#xD;
				Status.Err:=FALSE; Status.Cat:=FML_STATUS_CATEGORY_no_category; Status.ID:=FML_STATUS_ID_FB_no_error; &#xD;
				StepNo	:= 30;&#xD;
			ELSE										//  read the next PNU set&#xD;
				ixPNU		:= 0;&#xD;
				StepNo	:= 20;&#xD;
			END_IF;&#xD;
		END_IF;&#xD;
		&#xD;
		iSI						:= iSI + 1;			// set next subindex&#xD;
		&#xD;
	30: (* done *)&#xD;
		TimeStart			:= FALSE;&#xD;
		&#xD;
		FOR iSI := iSI TO maxDiagBuffElements DO&#xD;
			BufferForDiagEvent[0]							:=0;&#xD;
			AryByteTo(BufferForDiagEvent[0], 1, _LOW_HIGH, DiagBuff[iSI].DiagEvent);&#xD;
&#xD;
			DiagBuff[iSI].DiagMsgNumber			:= 16#FFFF;&#xD;
			DiagBuff[iSI].DiagMsgDescription		:= '';&#xD;
			DiagBuff[iSI].DiagTimeStamp				:= 0;&#xD;
		END_FOR	;&#xD;
    &#xD;
		Done			:= TRUE;  				// all things are done&#xD;
		StepNo  		:= 100;&#xD;
	&#xD;
	100:(* wait execute to be false *)&#xD;
		;&#xD;
END_CASE;&#xD;
&#xD;
Status.Msg								:= GetStatusMessage(Status);&#xD;
Error											:= Status.Err;&#xD;
&#xD;
(* ===== end of function block ====================================================== *)</Text></StructuredTextModel>