<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>(* ====== initial block routine ===================================== *)&#xD;
(* ----- get MemberID for this function block ------------------------*)&#xD;
IF NOT bInit THEN&#xD;
	FML_REF.MemberIDmax		:= FML_REF.MemberIDmax +1;&#xD;
	lMemberID            				:= FML_REF.MemberIDmax;&#xD;
	bInit              						:= TRUE;&#xD;
	Status.Err:=FALSE; Status.Cat:=FML_STATUS_CATEGORY_function_block; Status.ID:=FML_STATUS_ID_FB_init_active; &#xD;
END_IF;&#xD;
&#xD;
//no file transfer in CMMP-AS or CMMS_AS or CMMS_ST or CMMD_AS&#xD;
IF Execute &#xD;
	AND	((FML_REF.DeviceType = CMMP_AS) &#xD;
		OR (FML_REF.DeviceType = CMMS_AS) &#xD;
		OR (FML_REF.DeviceType = CMMS_ST)&#xD;
		OR (FML_REF.DeviceType = CMMD_AS)) THEN&#xD;
			Done				:= TRUE;&#xD;
			Status.Err:=TRUE; Status.Cat:=FML_STATUS_CATEGORY_function_block; Status.ID:=FML_STATUS_ID_FB_wrong_device; &#xD;
			StepNo			:= 27;&#xD;
END_IF;&#xD;
&#xD;
&#xD;
(* ===== logic part ================================================= *)&#xD;
IF NOT Execute AND (StepNo &lt;&gt; 0) THEN 														// reset all parameter (also bus data)&#xD;
	FML_REF.MemberID     							:= 0;&#xD;
	FML_REF.ReqID      	    							:= FML_FPC_REQ_none;&#xD;
	FML_REF.FPCC_Modus								:= 0;&#xD;
	FML_REF.FPCC_Packet.Control				:= 0;&#xD;
	FML_REF.FPCC_Packet.BitSequenceNr		:= 0;&#xD;
	FML_REF.FPCC_Packet.Data						:= ArrayWithZeros;&#xD;
&#xD;
	StepNo 								:= 0;&#xD;
END_IF;&#xD;
&#xD;
TONInst(IN := TimeStart, PT := T#3S, Q =&gt; TimeStop);										//timer for timeout&#xD;
&#xD;
&#xD;
CASE StepNo OF &#xD;
	0:(* initial prepare*)&#xD;
		Done					:= FALSE;&#xD;
		Sequence				:= 0;&#xD;
		CountByte 			:= 0;&#xD;
		FileSize					:= 0;&#xD;
		SendRepeat			:= 0;&#xD;
		Status.Err:=FALSE; Status.Cat:=FML_STATUS_CATEGORY_no_category; Status.ID:=FML_STATUS_ID_FB_no_error; &#xD;
    &#xD;
		IF Execute AND FML_REF.MemberID = 0 THEN											// parameterchannel is free&#xD;
			FML_REF.MemberID   		:= lMemberID;&#xD;
			FML_REF.ReqID				:= FML_FPC_REQ_none;&#xD;
					  &#xD;
    		// check for double mode selection by visu&#xD;
			IF NOT (Upload XOR Download) THEN  													// both or none are selected -&gt; error&#xD;
 				Status.Err:=TRUE; Status.Cat:=FML_STATUS_CATEGORY_parameter_transfer; Status.ID:=FML_STATUS_ID_FILE_direction_err; &#xD;
				StepNo						:= 27;&#xD;
       			RETURN;&#xD;
			&#xD;
			ELSIF Upload AND NOT Download THEN&#xD;
				Status.Err:=FALSE; Status.Cat:=FML_STATUS_CATEGORY_function_block; Status.ID:=FML_STATUS_ID_FB_busy; 		// execute starts here				&#xD;
				StepNo 						:= 1;																	// step 1 = starts upload&#xD;
			&#xD;
			ELSIF Download AND NOT Upload THEN&#xD;
				Status.Err:=FALSE; Status.Cat:=FML_STATUS_CATEGORY_function_block; Status.ID:=FML_STATUS_ID_FB_busy; 		// execute starts here&#xD;
				StepNo 						:= 6;																	// step 6 = starts download&#xD;
			END_IF;	&#xD;
&#xD;
	  	  // other FB active &#xD;
		ELSIF Execute AND FML_REF.MemberID &lt;&gt; lMemberId THEN&#xD;
			Status.Err:=FALSE; Status.Cat:=FML_STATUS_CATEGORY_function_block; Status.ID:=FML_STATUS_ID_FB_other_fb_active; 	&#xD;
		END_IF;&#xD;
		&#xD;
		&#xD;
    //===== upload handling ===============&#xD;
	1: (*start requirement - upload*)&#xD;
		FML_REF.FPCC_Modus 			    			:= 4;																				// choose mode&#xD;
		FML_REF.ReqID 										:= FML_FPC_REQ_read_file; 											// upload&#xD;
		FML_REF.FPCC_Packet.Control				:= DINT_TO_INT(FML_FPC_FILE_TRANSFER_start); 		// start transmission&#xD;
		FML_REF.FPCC_Packet.BitSequenceNr		:= Sequence;&#xD;
		FML_REF.FPCC_Packet.Data						:= DataBuffer;																// user data are zero&#xD;
		TimeStart 												:= TRUE; 																		// start timer for timeout&#xD;
		StepNo 													:= 2;&#xD;
		&#xD;
	2: (*wait for response from controller - upload*)&#xD;
		// controller also sends upload data with the size of the parameter file&#xD;
		IF FML_REF.RespID = FML_FPC_RESP_file_done AND FML_REF.FPCS_Packet.Control = FML_REF.FPCC_Packet.Control AND FML_REF.FPCS_Packet.BitSequenceNr = Sequence THEN&#xD;
			DataBuffer											:= FML_REF.FPCS_Packet.Data;									// write incoming data from controller into buffer (6 Byte)&#xD;
			&#xD;
			ParameterFile[iAddress]						:= DataBuffer[1];															// write data from buffer to output&#xD;
			ParameterFile[iAddress+1]					:= DataBuffer[2];	&#xD;
			ParameterFile[iAddress+2]					:= DataBuffer[3];	&#xD;
			ParameterFile[iAddress+3]					:= DataBuffer[4];	&#xD;
			ParameterFile[iAddress+4]					:= DataBuffer[5];	&#xD;
			ParameterFile[iAddress+5]					:= DataBuffer[6];	&#xD;
			&#xD;
			IF Sequence = 0 THEN 																											// save size of parameterfile&#xD;
				// calculate size of file as a multiple of udLength	&#xD;
				(* This action calculates the file size as a couple of 6 from the first 2 bytes of the buffer *)&#xD;
				FileSize		:= DWORD_TO_DINT( SHL(BYTE_TO_DWORD(DataBuffer[2]),8) OR BYTE_TO_DWORD(DataBuffer[1])); 							// length of data field&#xD;
				FileSize		:= (Filesize + 2 * udLength -1) / udLength ; 																														// +6: size of parameter file at first position, +5 und /6 for rounding up &#xD;
				FileSize		:= FileSize * udLength; &#xD;
				&#xD;
			&#xD;
				IF FileSize &gt; UINT_TO_DINT(SizeOfAry(ParameterFile)) THEN					// check if the array is big enough&#xD;
					Status.Err:=TRUE; Status.Cat:=FML_STATUS_CATEGORY_parameter_transfer; Status.ID:=FML_STATUS_ID_FILE_volumne_err; 	// array is to small --&gt; error state&#xD;
					StepNo 			    			:= 27;&#xD;
				END_IF;&#xD;
			END_IF;&#xD;
		 	&#xD;
			CountByte 								:= CountByte + udLength;								// count up the bytes&#xD;
			&#xD;
			IF Sequence = 31 THEN																					// count up the sequence&#xD;
				Sequence								:= 0;&#xD;
			ELSE&#xD;
				Sequence								:= Sequence + 1;&#xD;
			END_IF;&#xD;
			&#xD;
			TimeStart 								:= FALSE; 															// reset timer&#xD;
			StepNo 									:= 3;&#xD;
			&#xD;
		ELSE //---- timeout ----&#xD;
			IF TimeStop THEN&#xD;
				TimeStart 							:= FALSE; 															// reset timer&#xD;
				StepNo 								:= 4; 																// start acknowledgment is missing --&gt;  check Step 4 on error&#xD;
			END_IF;&#xD;
		END_IF;&#xD;
&#xD;
	3: (*request package - upload*)&#xD;
		FML_REF.FPCC_Packet.Control 				:= DINT_TO_INT(FML_FPC_FILE_TRANSFER_active);&#xD;
		FML_REF.FPCC_Packet.BitSequenceNr 	:= Sequence;&#xD;
		FML_REF.FPCC_Packet.Data						:= DataBuffer;										// user data&#xD;
		StepNo 													:= 4;&#xD;
&#xD;
	4: (*wait for answer - upload*)&#xD;
		TimeStart 												:= TRUE; 												// restart timer fot timeout (for each packet)&#xD;
		// expect and save packet&#xD;
		IF FML_REF.RespID = FML_FPC_RESP_file_done AND FML_REF.FPCS_Packet.Control = FML_REF.FPCC_Packet.Control AND FML_REF.FPCS_Packet.BitSequenceNr = Sequence THEN&#xD;
			DataBuffer											:= FML_REF.FPCS_Packet.Data;			// write incoming data from controller into buffer (6 Byte)&#xD;
			 &#xD;
			ParameterFile[CountByte]					:= DataBuffer[1];									// write data from buffer to output&#xD;
			ParameterFile[CountByte+1]				:= DataBuffer[2];	&#xD;
			ParameterFile[CountByte+2]				:= DataBuffer[3];	&#xD;
			ParameterFile[CountByte+3]				:= DataBuffer[4];	&#xD;
			ParameterFile[CountByte+4]				:= DataBuffer[5];	&#xD;
			ParameterFile[CountByte+5]				:= DataBuffer[6];	&#xD;
			&#xD;
			CountByte 						:= CountByte + udLength;										// count up the bytes&#xD;
			&#xD;
			IF Sequence = 31 THEN																					// count up the sequence&#xD;
				Sequence						:= 0;&#xD;
			ELSE&#xD;
				Sequence						:= Sequence + 1;&#xD;
			END_IF;&#xD;
			&#xD;
			TimeStart							:= FALSE;&#xD;
			StepNo							:= 3; &#xD;
		&#xD;
		// finish upload, controller sends stopp&#xD;
		ELSIF FML_REF.RespID = FML_FPC_RESP_file_done AND FML_REF.FPCS_Packet.Control = 2 (*FML_FPC_FILE_TRANSFER_stop*) AND (FML_REF.FPCS_Packet.BitSequenceNr = Sequence) THEN&#xD;
			TimeStart 						:= FALSE;&#xD;
			IF CountByte &lt;&gt; Filesize OR CountByte &lt; 100 THEN 									// check if all bytes are uploaded&#xD;
				Status.Err:=TRUE; Status.Cat:=FML_STATUS_CATEGORY_parameter_transfer; Status.ID:=(BYTE_TO_DINT(FML_REF.FPCS_Packet.Data[1])+1000);		&#xD;
				StepNo 			    		:= 21; 																		// wrong size --&gt; error state&#xD;
			ELSE&#xD;
				StepNo 			    		:= 20;																		// size is right, upload successful, end state		&#xD;
			END_IF;&#xD;
						&#xD;
		// error from controller, general EFPC error&#xD;
		ELSIF FML_REF.RespID = FML_FPC_RESP_error THEN&#xD;
			Status.Err:=TRUE; Status.Cat:=FML_STATUS_CATEGORY_parameter_transfer; Status.ID:=(BYTE_TO_DINT(FML_REF.FPCS_Packet.Data[1])+1000); 			// get error code from data at byte 1&#xD;
			TimeStart 						:= FALSE;																	&#xD;
			&#xD;
			IF Sequence = 31 THEN																					// count up the sequence&#xD;
				Sequence						:= 0;&#xD;
			ELSE&#xD;
				Sequence						:= Sequence + 1;&#xD;
			END_IF;&#xD;
			&#xD;
			StepNo 			  				:= 23;  																		// send stopp after error&#xD;
			&#xD;
		// error from controller - upload&#xD;
		ELSIF FML_REF.FPCS_Packet.Control = 3 (*FML_FPC_FILE_TRANSFER_error*) THEN&#xD;
			Status.Err:=TRUE; Status.Cat:=FML_STATUS_CATEGORY_parameter_transfer; Status.ID:=(BYTE_TO_DINT(FML_REF.FPCS_Packet.Data[1])+1000);			// get error code from data at byte 1&#xD;
			TimeStart							:= FALSE;&#xD;
			&#xD;
			IF Sequence = 31 THEN																					// count up the sequence&#xD;
				Sequence						:= 0;&#xD;
			ELSE&#xD;
				Sequence						:= Sequence + 1;&#xD;
			END_IF;&#xD;
			&#xD;
			StepNo							:= 23;  																		// send stopp after error	&#xD;
		&#xD;
		ELSE &#xD;
			//timeout&#xD;
			IF TimeStop THEN&#xD;
				Status.Err:=TRUE; Status.Cat:=FML_STATUS_CATEGORY_parameter_transfer; Status.ID:=FML_STATUS_ID_FILE_time_out; &#xD;
				StepNo						:= 21;  																		// send error message to controller&#xD;
				TimeStart						:= FALSE;&#xD;
			END_IF;&#xD;
		END_IF;&#xD;
	&#xD;
	6: (*start requirement - download*)&#xD;
		DataBuffer[1]						:= ParameterFile[CountByte];									// write data from data array (input) into buffer&#xD;
		DataBuffer[2]						:= ParameterFile[CountByte+1];	&#xD;
		DataBuffer[3]						:= ParameterFile[CountByte+2];	&#xD;
		DataBuffer[4]						:= ParameterFile[CountByte+3];	&#xD;
		DataBuffer[5]						:= ParameterFile[CountByte+4];	&#xD;
		DataBuffer[6]						:= ParameterFile[CountByte+5];	&#xD;
&#xD;
		IF Sequence = 0 THEN    											&#xD;
			// calculate size of file as a multiple of udLength	&#xD;
				(* This action calculates the file size as a couple of 6 from the first 2 bytes of the buffer *)&#xD;
				FileSize		:= DWORD_TO_DINT( SHL(BYTE_TO_DWORD(DataBuffer[2]),8) OR BYTE_TO_DWORD(DataBuffer[1])); 			// length of data field&#xD;
				FileSize		:= (Filesize + 2 * udLength -1) / udLength ; 																										// +6: size of parameter file at first position, +5 und /6 for rounding up &#xD;
				FileSize		:= FileSize * udLength; 																// calculate size of file as a multiple of udLength&#xD;
			&#xD;
			IF FileSize &lt; 262 THEN  																					// file larger than header --&gt; error&#xD;
				StepNo 						:= 27;&#xD;
				Status.Err:=TRUE; Status.Cat:=FML_STATUS_CATEGORY_parameter_transfer; Status.ID:=FML_STATUS_ID_FILE_size_err; &#xD;
				RETURN;&#xD;
				&#xD;
			ELSIF FileSize &gt; UINT_TO_DINT(SizeOfAry(ParameterFile)) THEN					// check if the array is big enough&#xD;
				StepNo 			    		:= 27; 																		// array is to small --&gt; error state&#xD;
				Status.Err:=TRUE; Status.Cat:=FML_STATUS_CATEGORY_parameter_transfer; Status.ID:=FML_STATUS_ID_FILE_volumne_err; &#xD;
				RETURN;&#xD;
			END_IF;&#xD;
		END_IF;	&#xD;
		&#xD;
		FML_REF.FPCC_Packet.Data						:= DataBuffer;										// write data from buffer to controller (6 byte)	&#xD;
		CountByte 												:= CountByte + udLength;&#xD;
		FML_REF.FPCC_Modus								:= 4;														// modus parameter file &#xD;
		FML_REF.ReqID										:= FML_FPC_REQ_write_file; 				// download&#xD;
		FML_REF.FPCC_Packet.Control				:= DINT_TO_INT(FML_FPC_FILE_TRANSFER_start); 		// start transfer&#xD;
		FML_REF.FPCC_Packet.BitSequenceNr		:= Sequence;&#xD;
		TimeStart 												:= TRUE;&#xD;
		StepNo 													:= 7;&#xD;
&#xD;
			&#xD;
	7: (*wait for response from controller - download*)&#xD;
		IF FML_REF.RespID = FML_FPC_RESP_file_done AND FML_REF.FPCS_Packet.Control = FML_REF.FPCC_Packet.Control AND FML_REF.FPCS_Packet.BitSequenceNr = Sequence THEN&#xD;
			Sequence 						:= 1;&#xD;
			StepNo 							:= 8;&#xD;
		ELSE&#xD;
			//timeout&#xD;
			IF TimeStop THEN&#xD;
				TimeStart 					:= FALSE;&#xD;
				StepNo 						:= 9;&#xD;
			END_IF;&#xD;
		END_IF;&#xD;
&#xD;
	8: (*send packet - download*)&#xD;
		IF CountByte &lt; FileSize THEN&#xD;
			DataBuffer[1]					:= ParameterFile[CountByte];									// write data from data array (input) into buffer&#xD;
			DataBuffer[2]					:= ParameterFile[CountByte+1];	&#xD;
			DataBuffer[3]					:= ParameterFile[CountByte+2];	&#xD;
			DataBuffer[4]					:= ParameterFile[CountByte+3];	&#xD;
			DataBuffer[5]					:= ParameterFile[CountByte+4];	&#xD;
			DataBuffer[6]					:= ParameterFile[CountByte+5];&#xD;
			&#xD;
			FML_REF.FPCC_Packet.Data						:= DataBuffer;									// write data from buffer to controller (6 byte)&#xD;
			CountByte												:= CountByte + udLength;&#xD;
			FML_REF.FPCC_Packet.Control				:= DINT_TO_INT(FML_FPC_FILE_TRANSFER_active);&#xD;
			FML_REF.FPCC_Packet.BitSequenceNr		:= Sequence;&#xD;
			StepNo													:= 9;&#xD;
				&#xD;
		ELSE          //---- end of file detected -Ã¤ stop to device&#xD;
			FML_REF.FPCC_Packet.Control 				:= DINT_TO_INT(FML_FPC_FILE_TRANSFER_stop);&#xD;
			FML_REF.FPCC_Packet.BitSequenceNr		:= Sequence;&#xD;
			FML_REF.FPCC_Packet.Data						:= DataBuffer;&#xD;
			StepNo													:= 9;&#xD;
		END_IF;&#xD;
	&#xD;
	9: (*wait for confirmation of receipt of controller - download*)&#xD;
		// receive and process message &#xD;
		TimeStart								:= TRUE;&#xD;
		IF FML_REF.RespID = FML_FPC_RESP_file_done AND FML_REF.FPCS_Packet.Control = 0 (*FML_FPC_FILE_TRANSFER_active*) AND (FML_REF.FPCS_Packet.BitSequenceNr = Sequence) THEN&#xD;
		&#xD;
			IF Sequence = 31 THEN																	// count up the sequence&#xD;
				Sequence						:= 0;&#xD;
			ELSE&#xD;
				Sequence						:= Sequence + 1;&#xD;
			END_IF;&#xD;
			&#xD;
			TimeStart							:= FALSE;       												&#xD;
			StepNo							:= 8;&#xD;
			&#xD;
		// if stop has been sent to the controller&#xD;
		ELSIF FML_REF.RespID = FML_FPC_RESP_file_done AND FML_REF.FPCS_Packet.Control = 2 (*FML_FPC_FILE_TRANSFER_stop*) AND (FML_REF.FPCS_Packet.BitSequenceNr = Sequence) THEN&#xD;
			IF CountByte &lt;&gt; Filesize OR CountByte &lt; 100 THEN 					// check if parameterfile has been loaded&#xD;
				StepNo 						:= 21; 														// wrong size, error step&#xD;
				Status.Err:=TRUE; Status.Cat:=FML_STATUS_CATEGORY_parameter_transfer; Status.ID:=FML_STATUS_ID_FILE_incomplete; &#xD;
			ELSE&#xD;
				StepNo 						:= 20;														// right size, download successful, end state    // check if all bytes are uploaded&#xD;
			END_IF;&#xD;
			&#xD;
			TimeStart 						:= FALSE;&#xD;
			&#xD;
		// error from controller, general EFPC error&#xD;
		ELSIF FML_REF.RespID = FML_FPC_RESP_error THEN&#xD;
			Status.Err:=TRUE; Status.Cat:=FML_STATUS_CATEGORY_parameter_transfer; Status.ID:=(BYTE_TO_DINT(FML_REF.FPCS_Packet.Data[1])+1000);		// get error code from data at byte 1	&#xD;
			&#xD;
			IF Sequence = 31 THEN																							// count up the sequence&#xD;
				Sequence						:= 0;&#xD;
			ELSE&#xD;
				Sequence						:= Sequence + 1;&#xD;
			END_IF;&#xD;
			&#xD;
			StepNo							:= 23;&#xD;
			TimeStart 						:= FALSE;&#xD;
			&#xD;
		// error form controller - Download&#xD;
		ELSIF FML_REF.FPCS_Packet.Control = 3 (*FML_FPC_FILE_TRANSFER_error*) THEN&#xD;
			Status.Err:=TRUE; Status.Cat:=FML_STATUS_CATEGORY_parameter_transfer; Status.ID:=(BYTE_TO_DINT(FML_REF.FPCS_Packet.Data[1])+1000);	  	// get error code from data at byte 1&#xD;
			&#xD;
      		IF Sequence = 31 THEN																							// count up the sequence&#xD;
				Sequence						:= 0;&#xD;
			ELSE&#xD;
				Sequence						:= Sequence + 1;&#xD;
			END_IF;&#xD;
			&#xD;
			IF tmpErrID = 8 THEN&#xD;
				StepNo 						:= 27;&#xD;
			ELSE&#xD;
				StepNo 						:= 23;&#xD;
			END_IF;&#xD;
			TimeStart 						:= FALSE;&#xD;
		&#xD;
		ELSE&#xD;
			// timeout&#xD;
			IF TimeStop THEN&#xD;
				Status.Err:=TRUE; Status.Cat:=FML_STATUS_CATEGORY_parameter_transfer; Status.ID:=FML_STATUS_ID_FILE_time_out; &#xD;
				StepNo 						:= 21;&#xD;
				TimeStart						:= FALSE;&#xD;
			END_IF;&#xD;
		END_IF;&#xD;
	&#xD;
	20:	(*  ==== done with no error ==== *)&#xD;
		Status.Err:=FALSE; Status.Cat:=FML_STATUS_CATEGORY_no_category; Status.ID:=FML_STATUS_ID_FB_no_error; &#xD;
		StepNo								:= 27;      																		// wait for NOT execute&#xD;
	&#xD;
		&#xD;
	21: (*send error message to Controller*)&#xD;
		IF Sequence = 31 THEN																							// count up the sequence&#xD;
			Sequence						:= 0;&#xD;
		ELSE&#xD;
			Sequence						:= Sequence + 1;&#xD;
		END_IF;&#xD;
		&#xD;
		FML_REF.FPCC_Modus 							:= 4;&#xD;
		FML_REF.FPCC_Packet.Control 				:= 3;&#xD;
		FML_REF.FPCC_Packet.BitSequenceNr  	:= Sequence;&#xD;
		FML_REF.FPCC_Packet.Data						:= DataBuffer;&#xD;
&#xD;
		TimeStart													:= TRUE;&#xD;
		StepNo 													:= 22;&#xD;
			&#xD;
	22: (*wait for error message from controller*)&#xD;
		IF FML_REF.RespID = FML_FPC_RESP_file_done AND FML_REF.FPCS_Packet.Control = 3 (*FML_FPC_FILE_TRANSFER_error*) THEN&#xD;
			&#xD;
			IF Sequence = 31 THEN																						// count up the sequence&#xD;
				Sequence						:= 0;&#xD;
			ELSE&#xD;
				Sequence						:= Sequence + 1;&#xD;
			END_IF;&#xD;
			&#xD;
			TimeStart							:= FALSE;&#xD;
			StepNo 							:= 23;&#xD;
		ELSE&#xD;
			IF TimeStop THEN&#xD;
				Status.Err:=TRUE; Status.Cat:=FML_STATUS_CATEGORY_parameter_transfer; Status.ID:=FML_STATUS_ID_FILE_time_out; &#xD;
				TimeStart 					:= FALSE;&#xD;
				StepNo 						:= 23;&#xD;
			END_IF;&#xD;
		END_IF;&#xD;
		&#xD;
	23: (*send STOPP after error*)	&#xD;
		FML_REF.FPCC_Packet.Control 					:= 2; 					// after error STOPP is sending to Controller&#xD;
		FML_REF.FPCC_Packet.BitSequenceNr 		:= Sequence;&#xD;
		FML_REF.FPCC_Packet.Data							:= DataBuffer;&#xD;
		TimeStart 													:= TRUE;&#xD;
		StepNo 														:= 24;		&#xD;
		&#xD;
	24: (*query wheater stop was confirmed by controller*)&#xD;
		IF (FML_REF.RespID = FML_FPC_RESP_file_done AND FML_REF.FPCS_Packet.Control = 2) OR (FML_REF.RespID = FML_FPC_RESP_error) THEN&#xD;
			StepNo 							:= 27;&#xD;
			TimeStart 						:= FALSE;&#xD;
		ELSIF FML_REF.RespID = FML_FPC_RESP_file_done AND FML_REF.FPCS_Packet.Control = 3 AND SendRepeat &lt; 4 THEN&#xD;
			Status.ID							:=(BYTE_TO_DINT(FML_REF.FPCS_Packet.Data[1])+1000);			// get error code from data at byte 1&#xD;
			IF Status.ID &lt;&gt; 1000 THEN&#xD;
				Status.Err						:=TRUE; &#xD;
				Status.Cat					:=FML_STATUS_CATEGORY_parameter_transfer;&#xD;
			END_IF;&#xD;
			&#xD;
			Sequence 						:= Sequence + 1;&#xD;
			SendRepeat 					:= SendRepeat + 1;&#xD;
			TimeStart 						:= FALSE;&#xD;
			StepNo 							:= 23;&#xD;
		ELSE&#xD;
			// timeout&#xD;
			IF TimeStop THEN&#xD;
				Status.Err:=TRUE; Status.Cat:=FML_STATUS_CATEGORY_parameter_transfer; Status.ID:=FML_STATUS_ID_FILE_time_out; &#xD;
				TimeStart 					:= FALSE;&#xD;
				StepNo 						:= 27;&#xD;
			END_IF;&#xD;
		END_IF;&#xD;
		&#xD;
  &#xD;
  27: (*idle - wait for execute = false*)&#xD;
		Done									:= TRUE;&#xD;
		StepNo								:= 30;&#xD;
    		&#xD;
  30: (*do nothing - wait for NOT execute*)&#xD;
    	;&#xD;
		&#xD;
END_CASE;&#xD;
&#xD;
Status.Msg									:= GetStatusMessage(Status);&#xD;
Error												:= Status.Err;&#xD;
&#xD;
(* ===== end of function block ============================= *)</Text></StructuredTextModel>